# Функции как объекты и их передача в Python

## 1. Основы функций как объектов

В Python функции — это объекты первого класса, что означает, что с ними можно работать как с обычными переменными.

```python
def calc():
    print(1 + 1)

# Вызов функции (выполняет код внутри)
calc()  # Выведет: 2

# Функция как объект (без вызова)
print(calc)  # Выведет что-то вроде: <function calc at 0x...>

# Присваивание функции другой переменной
new_calc = calc

# Теперь можно вызвать функцию через новое имя
new_calc()  # Выведет: 2
```

**Ключевое различие:**
- `функция` (без скобок) — сам объект функции, как "рецепт" или "инструкция"
- `функция()` (со скобками) — вызов функции, получение результата, как "готовое блюдо"

## 2. Функции внутри функций

Функции могут быть определены внутри других функций и могут возвращаться как результат.

```python
def greet():
    def hello():
        return 'hello'
    return hello()

print(greet())  # Выведет: hello
```

**Аналогия с матрёшками:**
- Большая матрёшка (`greet`) содержит маленькую (`hello`)
- Когда открываем большую, она достаёт и открывает маленькую
- И возвращает то, что было внутри маленькой ("hello")

## 3. Передача функций как аргументов

Функции можно передавать как аргументы другим функциям.

```python
def func1(give_me_a_func):
    print('before func')
    give_me_a_func()  # Вызов переданной функции
    print('after func')

def simple1():
    print('simple1')

def simple2():
    print('simple2')

# Вызов простых функций
simple1()  # Выведет: simple1
simple2()  # Выведет: simple2

# Передача функций как аргументов
func1(simple1)
# Выведет:
# before func
# simple1
# after func

func1(simple2)
# Выведет:
# before func
# simple2
# after func
```

**Процесс передачи функции:**
1. `func1(simple1)` — передаём функцию `simple1` как объект (без скобок)
2. Внутри `func1` параметр `give_me_a_func` становится равным функции `simple1`
3. Когда внутри `func1` выполняется `give_me_a_func()` (со скобками) — вызывается функция `simple1`

**Аналогия с матрёшками:**
1. Большая матрёшка (`func1`) имеет место для другой матрёшки (параметр)
2. Мы вкладываем среднюю матрёшку (`simple1`) в большую
3. Внутри большой матрёшки:
   - Она говорит "before func"
   - Открывает среднюю матрёшку с помощью скобок `()`
   - Средняя матрёшка показывает своё содержимое ("simple1")
   - Большая матрёшка говорит "after func"

**Аналогия с рецептом:**
- Передача функции как аргумента — это как передать рецепт торта (не готовый торт)
- Вызов функции внутри — это как приготовить торт по этому рецепту

## 4. Важность скобок

Скобки `()` играют ключевую роль:
- `функция` — объект функции (инструкция)
- `функция()` — вызов функции (выполнение инструкции)

```python
# Передаём саму функцию
func1(simple1)

# Внутри func1:
give_me_a_func()  # Вызываем переданную функцию
```

**Ключевой вывод:** Скобки `()` означают "выполни функцию сейчас и дай мне результат".

## 5. Применение этих концепций

Эти концепции являются основой для многих продвинутых техник в Python:

1. **Декораторы** — функции, которые принимают другие функции и расширяют их поведение
2. **Функции высшего порядка** — функции, которые принимают или возвращают другие функции
3. **Замыкания** — функции, которые запоминают окружение, в котором были созданы

Понимание функций как объектов открывает огромные возможности для создания гибкого, модульного и элегантного кода.



# Декораторы в Python: перезапись функций

## 1. Что такое декоратор

Декоратор — это функция, которая принимает другую функцию и расширяет её поведение, не изменяя код самой функции.

```python
def add_text(func):  # Это декоратор
    def wrapper():   # Функция-обертка
        print('before')
        func()       # Вызов оригинальной функции
        print('after')
    return wrapper   # Возвращаем новую функцию
```

## 2. Применение декоратора через перезапись

```python
# Определяем обычную функцию
def simple1():
    print('simple1')

# Вызываем оригинальную функцию
simple1()  # Выведет: simple1

# Применяем декоратор через перезапись
simple1 = add_text(simple1)  # Заменяем функцию на её декорированную версию

# Вызываем декорированную функцию
simple1()  # Выведет: before, simple1, after
```

## 3. Что происходит при перезаписи функции

1. **Оригинальная функция**: У нас есть функция `simple1`, которая просто выводит "simple1"
2. **Применение декоратора**: `simple1 = add_text(simple1)`
   - Декоратор `add_text` принимает функцию `simple1`
   - Создаёт новую функцию `wrapper`, которая обрамляет вызов оригинальной функции
   - Возвращает эту новую функцию
3. **Перезапись переменной**: Переменная `simple1` теперь указывает на новую функцию `wrapper`
4. **Вызов**: При вызове `simple1()` выполняется новая функция, которая:
   - Выводит "before"
   - Вызывает оригинальную функцию
   - Выводит "after"

## 4. Отличие от простой передачи функции

**Простая передача** (как в предыдущем примере):
```python
def func1(give_me_a_func):
    print('before func')
    give_me_a_func()
    print('after func')

func1(simple1)  # Одноразовый вызов с обрамлением
```

**Перезапись** (декорирование):
```python
simple1 = add_text(simple1)  # Постоянная модификация функции
simple1()  # Теперь каждый вызов будет обрамлен
```

**Ключевое отличие**:
- При простой передаче эффект временный и одноразовый
- При перезаписи изменение постоянное — всё, что использует `simple1`, будет вызывать улучшенную версию

## 5. Синтаксис декоратора в Python

В Python есть специальный синтаксис для декораторов с символом `@`:

```python
@add_text
def simple3():
    print('simple3')
```

Это эквивалентно:
```python
def simple3():
    print('simple3')
simple3 = add_text(simple3) #то есть simple3 теперь равно уже выполнению add_text с переданной внутрь simple3
```

## 6. Аналогии для лучшего понимания

**Матрёшки**:
- У нас была матрёшка `simple1`
- Мы положили её внутрь новой большой матрёшки `wrapper`
- Теперь имя `simple1` указывает на большую матрёшку
- Когда открываем большую, она сначала говорит "before", затем открывает маленькую, затем говорит "after"

**Рецепт**:
- У нас был рецепт печенья (`simple1`)
- Мы создали новый рецепт (`wrapper`), который включает старый, но добавляет шаги до и после
- Мы заменили оригинальный рецепт на новый
- Теперь всякий раз, когда кто-то просит рецепт печенья, они получают улучшенную версию

## 7. Практическое применение

Декораторы используются для:
- Логирования вызовов функций
- Измерения времени выполнения
- Проверки прав доступа
- Кэширования результатов
- Обработки исключений
- Мемоизации (запоминания результатов для одинаковых аргументов)

Основная идея: один код декоратора может быть применен к множеству функций, следуя принципу "не повторяйся" (DRY — Don't Repeat Yourself).
