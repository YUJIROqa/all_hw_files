# Работа с базами данных PostgreSQL в Python

## 1. Подключение к базе данных

**Определение:** Для работы с PostgreSQL используется библиотека psycopg2, которая позволяет устанавливать соединение с базой данных и выполнять SQL-запросы.

**Основные параметры подключения:**
- `host` - адрес сервера базы данных
- `database` - имя базы данных
- `user` - имя пользователя
- `password` - пароль для доступа
- `port` - порт сервера (стандартный для PostgreSQL - 5432)

**Разбор кода:**
```python
import psycopg2
import psycopg2.extras

db = psycopg2.connect(
    host = 'localhost',
    database = 'postgres',
    user = 'postgres',
    password = '1488',
    port = '5432'
)
```

**Аналогия:**
Подключение к базе данных похоже на вход в защищенное здание:
- Адрес сервера (`host`) — это адрес здания
- Имя базы (`database`) — конкретный офис внутри здания
- Пользователь и пароль (`user`, `password`) — пропуск и код доступа
- Порт (`port`) — номер входной двери

## 2. Создание курсора и выполнение запросов

**Определение:** Курсор — это объект, через который выполняются команды к базе данных и через который получаются результаты запросов.

**Основные операции с курсором:**
- Создание курсора: `db.cursor()`
- Выполнение SQL-запроса: `cursor.execute(query)`
- Получение результатов: `cursor.fetchall()`, `cursor.fetchone()`

**Разбор кода:**
```python
cursor = db.cursor(cursor_factory=psycopg2.extras.DictCursor) # Курсор, возвращающий словари
cursor.execute('SELECT * FROM students') # Выполнение SQL-запроса
data = cursor.fetchall() # Получение всех результатов

for student in data:
    print(student['last_name']) # Доступ к данным по имени столбца
```

**Аналогия:**
Курсор можно сравнить с официантом в ресторане:
- Создание курсора — вызов официанта к столу
- `execute()` — передача заказа официанту
- `fetchall()` — получение всех заказанных блюд сразу
- `fetchone()` — получение только одного блюда

## 3. Получение данных из результатов запроса

**Основные методы для получения результатов:**
- `fetchall()` — получить все строки результата
- `fetchone()` — получить только первую строку
- `fetchmany(n)` — получить n строк

**Разбор кода:**
```python
cursor.execute('SELECT * FROM students WHERE id = 2') # Первый запрос (результат не используется)
cursor.execute('SELECT * FROM students WHERE id = 3') # Второй запрос (перезаписывает результат первого)
data2 = cursor.fetchone() # Получение одной строки результата

print(data2) # Вывод результата в исходном виде
print(dict(data2)) # Преобразование результата в обычный словарь
```

**Важное замечание:**
Если выполнить несколько запросов подряд без получения результата, запомнится только результат последнего запроса. Поэтому нужно вызывать `fetchall()` или `fetchone()` после каждого `execute()`, результат которого важен.

## 4. Параметризованные запросы и защита от SQL-инъекций

**Определение:** SQL-инъекция — это атака, когда вредоносный код вставляется в SQL-запрос через пользовательский ввод. Параметризованные запросы защищают от такой атаки.

**Методы работы с параметрами:**
- Параметризация с `%s`: безопасное добавление значений в запрос
- Передача значений через кортеж: `(value1, value2, ...)`

**Разбор кода:**
```python
# Небезопасный способ (закомментирован)
# query = "SELECT * FROM students WHERE first_name = '{0}' and last_name = '{1}'"

# Безопасный способ с параметризацией
query = "SELECT * FROM students WHERE first_name = %s and last_name = %s"
cursor.execute(query, (input('first_name: '), input('last_name: ')))
print(cursor.fetchone())
```

**Как работает параметризация:**
1. Создается шаблон запроса с маркерами `%s` вместо значений
2. При выполнении запроса psycopg2 безопасно подставляет значения из кортежа на места маркеров
3. База данных обрабатывает значения параметров отдельно от SQL-кода, что предотвращает инъекции

**Аналогия:**
Параметризованные запросы похожи на анкету с пропусками:
- SQL-запрос — это анкета с пустыми полями
- Маркеры `%s` — это пустые поля для заполнения
- Кортеж с данными — это ручка, которой заполняются поля
- База данных понимает разницу между анкетой и тем, что в неё вписано

## 5. Вставка данных и сохранение изменений

**Определение:** Для изменения данных в базе (INSERT, UPDATE, DELETE) требуется не только выполнить SQL-запрос, но и подтвердить изменения через `commit()`.

**Основные операции:**
- Выполнение запроса на изменение: `cursor.execute(insert_query)`
- Сохранение изменений: `db.commit()`

**Разбор кода:**
```python
cursor.execute("INSERT INTO students (first_name, last_name, grade, group_id) VALUES ('Сидр', 'Сидоров', 5, 1)")
db.commit() # Сохранение изменений в базе данных
```

**Важное замечание:**
Без вызова `commit()` изменения не будут постоянными и могут быть потеряны при закрытии соединения или сбое программы.

**Аналогия:**
Процесс изменения данных похож на редактирование документа:
- `execute()` — внесение изменений в черновик
- `commit()` — нажатие кнопки "Сохранить"
- Без `commit()` все изменения останутся только в черновике и будут утеряны при закрытии программы

## 6. Интерактивное меню с использованием match-case

**Определение:** Структурный шаблон match-case (доступен с Python 3.10) удобен для создания меню и обработки разных команд пользователя.

**Основные элементы:**
- `match выражение:` — начало блока сопоставления
- `case шаблон:` — конкретный вариант значения
- `case _:` — вариант "по умолчанию"

**Разбор кода:**
```python
while True:
    user_input2 = input('Say something: ')
    match user_input2:
        case 'hello': # Если ввод == 'hello'
            print('Hello!')
        case 'bye':
            print('Bye!')
        case 'end':
            print('Goodbye!')
            break # Выход из цикла
        case _: # Для любого другого ввода
            print('Hi or bye')
```

**Аналогия:**
Match-case похож на администратора ресторана:
- Вы произносите фразу
- Администратор сравнивает её со списком возможных запросов
- В зависимости от совпадения выполняется определенное действие
- Если фраза не соответствует ни одному запросу, выполняется действие "по умолчанию"

## 7. Обработка ошибок при работе с базой данных

**Определение:** При работе с базами данных могут возникать различные ошибки, которые нужно корректно обрабатывать с помощью блоков try-except.

**Основные типы ошибок:**
- `psycopg2.DatabaseError` — общий класс для ошибок базы данных
- `psycopg2.OperationalError` — проблемы с соединением
- `psycopg2.ProgrammingError` — ошибки в SQL-синтаксисе

**Разбор кода:**
```python
while True:
    user_input = input('Введите команду: ')
    match user_input:
        case 'show all':
            try:
                cursor.execute("SELECT * FROM students")
                students = cursor.fetchall() 
            except psycopg2.DatabaseError as err:
                print(err)
        case 'find by name':
            try:
                name = input('Введите имя: ')
                cursor.execute("SELECT * FROM students WHERE first_name = %s", (name,))
            except psycopg2.DatabaseError as err:
                print(err)
        case 'exit':
            break
        case _:
            print('Неизвестная команда')
```

**Ключевое исправление:**
В команде 'find by name' был неправильный запрос с ошибкой в форматировании:
```python
cursor.execute("SELECT * FROM students WHERE first_name = {name}")
```

Исправлено на правильный параметризованный запрос:
```python
cursor.execute("SELECT * FROM students WHERE first_name = %s", (name,))
```

**Аналогия:**
Обработка ошибок базы данных похожа на предвидение проблем при походе в магазин:
- Пытаемся выполнить задачу (найти товар) — блок `try`
- Если возникает проблема (товара нет) — перехватываем её в блоке `except`
- Вместо аварийного завершения программы выводим понятное сообщение и продолжаем работу

## 8. Закрытие соединения

**Определение:** После завершения работы с базой данных необходимо корректно закрыть соединение для освобождения ресурсов.

**Операция закрытия:**
```python
db.close()
```

**Важность закрытия соединения:**
- Освобождение ресурсов сервера базы данных
- Предотвращение блокировок и утечек памяти
- Завершение всех незавершенных транзакций

**Аналогия:**
Закрытие соединения с базой данных похоже на выход из здания:
- Завершение всех дел (`commit()` всех изменений)
- Закрытие кабинета и сдача ключей (`db.close()`)
- Игнорирование этого шага может привести к "незапертым дверям" и проблемам безопасности

## 9. Ключевые моменты понимания

**Связь между параметрами и маркерами `%s`:**
1. `%s` в SQL-запросе — это метка для подстановки значения
2. Кортеж после запроса (например, `(name,)`) — это данные для подстановки
3. Порядок значений в кортеже соответствует порядку маркеров `%s` в запросе

**Примеры подстановки значений:**
```python
# Один параметр
name = "Иван"
cursor.execute("SELECT * FROM students WHERE first_name = %s", (name,))
# Запрос становится: SELECT * FROM students WHERE first_name = 'Иван'

# Два параметра
first = "Иван"
last = "Петров"
cursor.execute("SELECT * FROM students WHERE first_name = %s AND last_name = %s", (first, last))
# Запрос становится: SELECT * FROM students WHERE first_name = 'Иван' AND last_name = 'Петров'
```

**Безопасность и SQL-инъекции:**
- Параметризованные запросы с `%s` защищают от SQL-инъекций
- Опасно использовать форматирование строк (f-строки или `.format()`) для SQL
- При параметризации специальные символы в данных экранируются автоматически

**Выполнение запросов и получение результатов:**
- Всегда получайте результат после `execute()`, если он вам нужен
- Используйте подходящий метод: `fetchall()` для всех строк, `fetchone()` для одной строки
- Обрабатывайте результаты с учетом их структуры (словарь с ключами-столбцами)

Работа с базами данных — это важный навык, который позволяет создавать приложения с сохранением и обработкой структурированных данных. Правильное использование параметризованных запросов и обработка ошибок делают ваши программы более надежными и защищенными.
